<link rel="import" href="../bower_components/polymer/polymer.html">
<link rel="import" href="../bower_components/paper-spinner/paper-spinner-lite.html">

<dom-module id="jlramosr-drag-element">

  <template>

    <style>
      :host {
        position: absolute;
        top: 0;
        left: 0;
        width: var(--josito-drag-element-width, 50px);
        height: var(--josito-drag-element-height, 50px);
        opacity: 0.8;

        background-color: var(--google-yellow-500);
        border-radius: 50%;
        cursor: pointer;
        /* 
         * Disable predetermined touch events (user agent is new manager).
         *
         * It's used to allow pointer events.
         * User agent is the new manager and it listens events of user agent like pointer events.
         */ 
         touch-action: none;
      }

      :host([selected]) {
        opacity: 1;
        user-select: none;
        -moz-user-select: none;
        -khtml-user-select: none;
        -webkit-user-select: none;
        /* Required to make elements draggable in old WebKit */
        -khtml-user-drag: element;
        -webkit-user-drag: element;
        cursor: grabbing;
        cursor: -moz-grabbing;
        cursor: -webkit-grabbing;
      }

      :host([dragging]) {
        display: none;
        cursor: grabbing;
        cursor: -moz-grabbing;
        cursor: -webkit-grabbing;
      }

      .spinner {
        --paper-spinner-stroke-width: 1px;
        --paper-spinner-color: var(--google-green-500);
        width: var(--josito-drag-element-width, 50px);
        height: var(--josito-drag-element-height, 50px);
      }

    </style>

    <paper-spinner-lite id="spinner" class="spinner" active="[[_computeSpinnerActive(selected, dragging)]]"></paper-spinner-lite>

  </template>
</dom-module>

<script>
  (function() {
    'use strict';

    Polymer({

      is: 'jlramosr-drag-element',

      properties: {

        /**
         * It indicates if element is ready to move.
         */ 
        selected: {
          type: Boolean,
          reflectToAttribute: true,
          readOnly: true,
          value: false,
        },

        /**
         * It indicates if element is being dragged.
         */ 
        dragging: {
          type: Boolean,
          reflectToAttribute: true,
          readOnly: true,
          value: false
        },

        /**
         * Exact pointer position on the x-asis when user press with the mouse or touch on element.
         */ 
        pointerDownPositionX: Number,

        /**
         * Exact pointer position on the y-asis when user press with the mouse or touch on element.
         */ 
        pointerDownPositionY: Number,

        /**
         * Upper left corner position of the element on the x-asis.
         */ 

        cornerPositionX: Number,
        /**
         * Upper left corner position of the element on the y-asis.
         */ 
        cornerPositionY: Number,

        /**
         * It indicates if element movement has animation.
         */ 
        hasAnimation: {
          type: Boolean,
          readOnly: true,
          value: true
        },

      },

      listeners: {
        'tap': '_onTap',
        'drag': '_onStartDrag',
        'dragend': '_onEndDrag',
        'pointerdown': '_onPointerDown',
      },

      /**
       * Fired when the user press the mouse or touch on element.
       *
       * It updates pointer position. It has not done on tap listener because it is not called
       * when user drags the element and this listener has.
       */ 
      _onPointerDown(event) {
         this.pointerDownPositionX = event.clientX;
         this.pointerDownPositionY = event.clientY; 
      },

      /**
       * Fired when the user press down and press up on element without dragging it.
       *
       * It toggles selected element attribute.
       */ 
      _onTap(event) {
        this.selected ? this._setSelected(false) : this._setSelected(true);
      },

      /**
       * Fired when user starts to drag.
       *
       * It changes dragging element attribute.
       */ 
      _onStartDrag(event) {
        if (!this.dragging) {
          event.preventDefault();
          this._setDragging(true);
        }
      },

      /**
       * Fired when user finish to drag.
       *
       * It moves the element and updates upper left corner position of the element considering this 
         old position andthe cursor position.
       */ 
      _onEndDrag(event) {
        if (this.dragging) {
          this._setDragging(false);
          const oldCornerPositionX = this.cornerPositionX ? this.cornerPositionX : 0;
          const oldCornerPositionY = this.cornerPositionY ? this.cornerPositionY : 0;
          const newCornerPositionX = event.clientX + oldCornerPositionX - this.pointerDownPositionX;
          const newCornerPositionY = event.clientY + oldCornerPositionY - this.pointerDownPositionY;
          if (this.hasAnimation) {
            const animation = this.animate([
              { 'transform': `translate(${oldCornerPositionX}px, ${oldCornerPositionY}px)` }, 
              { 'transform': `translate(${newCornerPositionX}px, ${newCornerPositionY}px)` }
            ], { 
              duration: 800,
              easing: 'cubic-bezier(0.175, 0.885, 0.32, 1.275)'
            });
          }
          this.translate3d(newCornerPositionX + 'px', newCornerPositionY + 'px', 0);
          this.cornerPositionX = newCornerPositionX;
          this.cornerPositionY = newCornerPositionY;
        }
      },

      _computeSpinnerActive(selected, dragging) {
        return selected && !dragging;
      }

  });
}());
</script>

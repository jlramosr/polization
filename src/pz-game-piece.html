<link rel="import" href="../bower_components/polymer/polymer.html">
<link rel="import" href="../bower_components/paper-spinner/paper-spinner-lite.html">

<dom-module id="pz-game-piece">

  <template>

    <style>
      :host {
        display: none;
        width: var(--app-piece-size);
        height: var(--app-piece-size);
        display: none;
        opacity: 0.5;
      }

      :host([is-my-turn][mine]:not([selected]):not([rest-movements="0"])) {
        cursor: pointer;
      }

      :host([selected]) {
        opacity: 1;
        cursor: grabbing;
        cursor: -moz-grabbing;
        cursor: -webkit-grabbing;
      }

      .icon {
        z-index: 1;
      }

      .spinner {
        --paper-spinner-stroke-width: 6px;
        --paper-spinner-color: var(--google-green-500);
        position: absolute;
        top: -2px;
        left: -2px;
        width: calc(100% + 4px);
        height: calc(100% + 4px);
        z-index: 0;
      }

      .info {
        position: absolute;
        font-size: 12px;
        right: -5px;
        bottom: -5px;
        font-weight: bold;
        z-index: 2;
      }

    </style>


    <div id="pieceContainer">
      <iron-icon class="icon" style$="color:[[color]];" icon$="[[type]]"></iron-icon>
      <paper-spinner-lite class="spinner" active="[[_computeSpinnerActive(selected, dragging)]]"></paper-spinner-lite>
      <template is="dom-if" if="[[mine]]">
        <span style$="color:[[color]];" class="info">{{restMovements}}</span>
      </template>
    </div>


  </template>

  <script>

    Polymer({

      is: 'pz-game-piece',

      properties: {

        width: {
          type: Number,
          readOnly: true,
          value: 24
        },

        squareWidth: Number,

        clientX: Number,

        clientY: Number,

        positionX: Number,

        positionY: Number,

        /**
         * It indicates if piece is ready to move.
         */ 
        selected: { 
          type: Boolean,
          reflectToAttribute: true,
          value: false,
          observer: '_selectedChanged'
        },


        /**
         * It indicates if piece is being dragged.
         */ 
        dragging: {
          type: Boolean,
          reflectToAttribute: true,
          readOnly: true,
          value: false
        },

        user: {
          type: String,
          value: ''
        },

        isMyTurn: { 
          type: Boolean,
          reflectToAttribute: true,
        },

        mine: { 
          type: Boolean,
          reflectToAttribute: true,
        },

        type: String,

        color: String,

        maxMovements: Number,

        restMovements: {
          type: Number,
          observer: '_restMovementsChanged',
          reflectToAttribute: true
        },

        defense: Number,

        attack: Number,

        /**
         * Exact pointer position on the BROWSER x-asis when user press with the mouse or touch on object.
         */ 
        pointerDownX: {
          type: Number,
          readOnly: true,
        },

        /**
         * Exact pointer position on the BROWSER y-asis when user press with the mouse or touch on object.
         */ 
        pointerDownY: {
          type: Number,
          readOnly: true,
        },

        /**
         * Last pointer position on the BROWSER x-asis when user is dragging the object.
         */ 
        lastPointerDragX: {
          type: Number,
          readOnly: true
        },

        /**
         * Last pointer position on the BROWSER y-asis when user is dragging the object.
         */ 
        lastPointerDragY: {
          type: Number,
          readOnly: true
        }

      },

      observers: [
        '_positionChanged(positionX, positionY, squareWidth)'
      ],

      behaviors: [
        Polymer.IronResizableBehavior
      ],





      created() {
        this._onIronResize = this._onIronResize.bind(this);
        this._onKeyDown = this._onKeyDown.bind(this);
      },

      attached() {
        this._toggleListeners(true);
        this.style.display = 'block';
      },

      detached() {
        this._toggleListeners(false);
      },

      _toggleListeners(enable) {
        const m = enable ? 'addEventListener' : 'removeEventListener';
        if (this.mine) {
          this[m]('pointerdown', this._onPointerDown);
          this[m]('pointerup', this._onPointerUp);
          this[m]('pointermove', this._onPointerMove);
          this[m]('pointerleave', this._onPointerLeave);
        }  
        this[m]('iron-resize', this._onIronResize);
        document.body[m]('keydown', this._onKeyDown);
      },





      _positionChanged(positionX, positionY, squareWidth) {
        this._moveToClient(this._getCoordinateClient(positionX), this._getCoordinateClient(positionY));
      },


      _restMovementsChanged(restMovements) {
        if (!restMovements) {
          this._setDragging(false);
          this.selected = false;
        }
      },

      _selectedChanged(selected) {
        if (selected) {
          this.fire('piece-selected', this);
        }
      },




  

      _onIronResize(event) {
        
      },


      /**
       * Fired when the user press the mouse over the piece or touch the element.
       *
       * It updates pointer down position of the piece and initialize the position of the drag.
       */ 
      _onPointerDown(event) {

        if (this.isMyTurn && this.restMovements > 0) {

          const pointerX = event.clientX;
          const pointerY = event.clientY;

          this._setPointerDownX(pointerX);
          this._setPointerDownY(pointerY);

          if (this.selected) {
            this._setDragging(true);
            this._setLastPointerDragX(pointerX);
            this._setLastPointerDragY(pointerY);
          }

        }

      },

      /**
       * Fired when the user stop clicking or touching the element.
       *
       * It's a handler of object selected property. Always set dragging to false, updating the new corner of the object.
       */ 
      _onPointerUp(event) {

        if (this.isMyTurn && this.restMovements > 0) {

          const pointerX = event.clientX;
          const pointerY = event.clientY;

          const samePositionDown = (pointerX ==  this.pointerDownX && pointerY == this.pointerDownY);
          if (samePositionDown) {
            this.selected = !this.selected;
          }

          if (this.dragging && !samePositionDown) {
            this.fire('piece-finish-drag', this);
          }

          this._setDragging(false);

        }

      },

      /**
       * Fired when the user moves the mouse or finger or pen over the element.
       *
       * If the object is being dragged, update its position through the element.
       */ 
      _onPointerMove(event) {
        
        if (this.selected && this.dragging) {

            const pointerX = event.clientX;
            const pointerY = event.clientY;
            
            const movementX = pointerX - this.lastPointerDragX;
            const movementY = pointerY - this.lastPointerDragY;

            this._setLastPointerDragX(pointerX);
            this._setLastPointerDragY(pointerY);

            const newClientX = this.clientX + movementX;
            const newClientY = this.clientY + movementY;

            this._moveToClient(newClientX, newClientY);
            this.fire('piece-dragging', this);

        }

      },

      /**
       * Fired when user press down a key.
       */ 
      _onKeyDown(event) {

        const escKey = 27;
        const arrowLeftKey = 37;
        const arrowUpKey = 38;
        const arrowRightKey = 39;
        const arrowDownKey = 40;
        const f5Key = 116;

        if (this.selected) {
        }

      },




      _moveToClient(clientX, clientY) {
        const centerClientX = (clientX - this.width/2);
        const centerClientY = (clientY - this.width/2);

        this.translate3d(centerClientX + 'px', centerClientY + 'px', 0);

        this.clientX = clientX;
        this.clientY = clientY;
      },

      _getCoordinatePosition(coordinateClient) {
        const positionDecimal = coordinateClient / this.squareWidth;
        return Math.trunc(positionDecimal);
      },

      _getCoordinateClient(coordinatePosition) {
        return this.squareWidth * (coordinatePosition + 0.5);
      },






      _computeSpinnerActive(selected, dragging) {
        return selected && !dragging;
      }

    });

  </script>

</dom-module>
